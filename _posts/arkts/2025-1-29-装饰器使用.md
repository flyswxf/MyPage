---
layout: post
title: "通过装饰器传值"
date: 2025-01-29
categories: arkts
---

# @State

@State装饰的变量更新会引起它所作用的**局部**渲染更新
例如：
```ts
@Entry
@Component
struct MyComponent {
  @State count: number = 0;

  build() {
    Button(`click times: ${this.count}`)
      .onClick(() => {
        this.count += 1;
      })
  }
}
```

# @Link，@Prop
如果@State装饰的变量作用的局部是**子组件中**，则不会更新！

此时需要使用@Link和@Prop实现**父组件到子组件**的参数传递

```ts
@Component
struct ChildComponent {
  @Prop ChildData: number = 10

  build() {
    Column() {
      Button('child data set to 100')
        .margin(10)
        .onClick(() => {
          this.ChildData = 100;
        })
    }
  }
}

@Entry
@Component
struct ParentComponent {
  @State PartenntData: number = 10

  build() {
    Column() {
      Button('parent data net to 1')
        .margin(10)
        .onClick(() => {
          this.ParentData = 10
        })

      ChildComponent({ ChildData: this.ParentData })
    }

  }
}
```
## @Prop的使用方法： 

1. **父组件装饰器**：任意，常规变量（无装饰器也可以）
2. **显式传递**：在调用子组件时显式地传递参数
3. **子组件值**：可以在子组件内部赋初始值，传递参数时会更新，如果不传递参数则以初始值为准。（因此@Prop不传递参数不会报错，需要注意以防没有传递参数）

## @Prop的作用
从父组件到子组件的单层单向传递
1. **单层**：如果传递的是类，只能观察类的变量，不能观察类的类的变量
```ts
class Info {
  public value: string;
  constructor(value: string) {
    this.value = value;
  }
}
class Model {
  public value: string; // 类的变量，可以观察
  public info: Info; // 类的类的，不能观察
  constructor(value: string, info: Info) {
    this.value = value;
    this.info = info;
  }
}
```
2. **单向**：父组件中变量的变化会影响子组件的渲染，但子组件内部的变化不会影响父组件，也不会影响兄弟组件

## @Link的使用方法

1. **父组件装饰器**：任意，但不能是常规变量（因为是双向同步，常规变量更新不会重新传染，没有使用双向的必要）
2. **显式传递**：在调用子组件时显式地传递参数
3. **子组件值**：不允许在子组件内部赋初始值

## @Link的作用
从父组件到子组件的单层双向传递

1. **单层**：如果传递的是类，只能观察类的变量，不能观察类的类的变量
2. **单向**：父组件中变量的变化会影响子组件的渲染，子组件内部的变化也影响父组件，如果该变量还被传递到兄弟组件，则也会影响兄弟组件




