---
category: C++
---

# Access specifiers
 - ### public:
    1. 可访问性：`public` 成员在类的内部和外部都是可访问的。这意味着，一个类的对象可以直接访问其 `public` 成员。

    2. 继承：在继承中，基类的 `public` 成员会被派生类继承，并且在派生类中仍然保持 `public` 访问级别。这意味着，派生类的对象也可以直接访问从基类继承来的 `public` 成员。

    3. 使用场景：通常，类的接口（即，可以被类的用户安全访问和使用的部分）是通过 `public` 成员来暴露的。这包括类的构造函数、析构函数、成员函数（方法）和某些数据成员。
    ```cpp
    class MyClass {
    public:
        int publicData; // 公有数据成员
        MyClass() { publicData = 5; } // 公有构造函数
        void publicFunction() { // 公有成员函数
            // 函数体
        }
    };

    int main() {
        MyClass obj;
        obj.publicData = 10; // 直接访问公有数据成员
        obj.publicFunction(); // 直接调用公有成员函数
        return 0;
    }
    ```

 - ### private
   1. 可访问性：`private` 成员只能被其所在类的成员函数、友元函数以及该类的任何派生类（通过基类的成员函数或友元函数）访问。它们不能被类的对象直接访问。

    2. 继承：在继承中，基类的 `private` 成员也会被派生类继承，但是它们在派生类中仍然保持 `private` 访问级别，这意味着派生类不能直接访问这些成员。只有基类的成员函数和友元函数可以访问这些 `private` 成员。

    3. 使用场景：通常，`private` 成员用于实现类的内部逻辑，它们是类的实现细节，不应该被类的用户直接访问。这有助于实现封装和数据隐藏，是面向对象编程的一个重要概念。
    ```cpp
    class MyClass {
    private:
        int privateData; // 私有数据成员

    public:
        MyClass() { privateData = 5; } // 公有构造函数
        void setPrivateData(int value) { privateData = value; } // 公有成员函数，用于设置私有数据成员的值
        int getPrivateData() { return privateData; } // 公有成员函数，用于获取私有数据成员的值
    };

    int main() {
        MyClass obj;
        obj.setPrivateData(10); // 通过公有成员函数间接访问私有数据成员
        int data = obj.getPrivateData(); // 通过公有成员函数间接访问私有数据成员
        return 0;
    }
    ```
- ### protected
    1. 可访问性：`protected` 成员既可以被其所在类的成员函数访问，也可以被派生类中的成员函数访问，但不能被类的对象直接访问。

继承：在继承中，基类的 `protected` 成员在派生类中保持 `protected` 状态，这意味着它们可以被进一步派生的类访问。这与 `private` 成员不同，`private` 成员即使被继承，也不能在派生类中直接访问。

使用场景：`protected` 成员通常用于那些需要在派生类中访问，但不希望在类的外部直接访问的情况。这有助于在保持一定的封装性的同时，提供一种灵活的方式来共享类的内部实现。

```cpp
class BaseClass {
protected:
    int protectedData; // 受保护的数据成员

public:
    BaseClass() { protectedData = 5; }
    void setProtectedData(int value) { protectedData = value; }
};

class DerivedClass : public BaseClass {
public:
    void modifyProtectedData(int value) {
        // 直接访问受保护的数据成员
        protectedData = value;
    }
};

int main() {
    DerivedClass obj;
    obj.setProtectedData(10); // 通过基类的公有成员函数间接设置受保护的数据成员
    obj.modifyProtectedData(15); // 直接在派生类中修改受保护的数据成员
    return 0;
}
```

# 例子
```cpp
// classes example
#include <iostream>
using namespace std;

class Rectangle {
    int width, height;
  public:
    void set_values (int,int);
    int area() {return width*height;}
};

void Rectangle::set_values (int x, int y) {
  width = x;
  height = y;
}

int main () {
  Rectangle rect;
  rect.set_values (3,4);
  cout << "area: " << rect.area();
  return 0;
}
```
- 写在`class`内的函数视作`inline`
- 未加成员类型,默认为`private`
